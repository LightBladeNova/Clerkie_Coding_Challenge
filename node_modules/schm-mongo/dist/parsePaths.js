"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _omit = require("lodash/omit");

var _omit2 = _interopRequireDefault(_omit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var getPathValuesFromObject = function getPathValuesFromObject(object, path) {
  if (object[path]) {
    return [object[path]];
  }
  if (object.$and) {
    return object.$and.reduce(function (finalValues, currentObject) {
      return [].concat(finalValues, getPathValuesFromObject(currentObject, path));
    }, []);
  }
  return [];
};

var removePathsFromObject = function removePathsFromObject(object, paths) {
  var finalObject = (0, _omit2.default)(object, paths);
  var removeFromArray = function removeFromArray(array) {
    return array.reduce(function (finalArray, currentObject) {
      return [].concat(_toConsumableArray(finalArray), [removePathsFromObject(currentObject, paths)]);
    }, []).filter(function (x) {
      return Object.keys(x).length;
    });
  };

  if (finalObject.$and) {
    return _extends({}, finalObject, {
      $and: removeFromArray(finalObject.$and)
    });
  }
  return finalObject;
};

var parsePaths = function parsePaths(values, pathsMap) {
  return Object.keys(values).reduce(function (finalObject, key) {
    var _ref;

    var paths = [].concat(pathsMap[key] || []);

    if (!paths.length) {
      return finalObject;
    }

    var existingPathsValues = (_ref = []).concat.apply(_ref, _toConsumableArray(paths.map(function (path) {
      var pathValues = getPathValuesFromObject(finalObject, path);
      if (pathValues.length) {
        return pathValues.map(function (val) {
          return _defineProperty({}, path, val);
        });
      }
      return [];
    })));

    var value = paths.map(function (path) {
      return _defineProperty({}, path, values[key]);
    });
    var finalValue = value.length === 1 ? value[0] : { $or: value };
    var normalizedObject = removePathsFromObject(finalObject, [key].concat(_toConsumableArray(paths)));

    if (existingPathsValues.length) {
      return {
        $and: [].concat(normalizedObject.$and || (Object.keys(normalizedObject).length ? normalizedObject : []), existingPathsValues, finalValue)
      };
    }

    return _extends({}, normalizedObject, finalValue);
  }, values);
};

exports.default = parsePaths;