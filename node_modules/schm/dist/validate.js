"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _schema = require("./schema");

var _schema2 = _interopRequireDefault(_schema);

var _mapValues = require("./mapValues");

var _mapValues2 = _interopRequireDefault(_mapValues);

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var isPrimitive = function isPrimitive(arg) {
  return arg == null || (typeof arg === "undefined" ? "undefined" : _typeof(arg)) !== "object" && typeof arg !== "function";
};

var replaceMessage = function replaceMessage(message, paramName, value, validatorName) {
  return message.replace(/\{(PARAM|PATH)\}/g, paramName).replace(/\{VALUE\}/g, value).replace(/\{(VALIDATOR|TYPE)\}/g, validatorName);
};

var createErrorObject = function createErrorObject(param, value, validator, optionValue, message) {
  return _extends({
    param: param
  }, isPrimitive(value) ? { value: value } : {}, {
    validator: validator
  }, isPrimitive(optionValue) ? _defineProperty({}, validator, optionValue) : {}, message ? { message: replaceMessage(message, param, value, validator) } : {});
};

/**
 * Validates a schema based on given values.
 * @example
 * const schema = require('schm')
 * const { validate } = schema
 *
 * const userSchema = schema({
 *   name: {
 *     type: String,
 *     required: true,
 *   },
 *   age: {
 *     type: Number,
 *     min: [18, 'Too young'],
 *   }
 * })
 *
 * validate({ name: 'John', age: 17 }, userSchema)
 *   .then((parsedValues) => {
 *     console.log('Yaay!', parsedValues)
 *   })
 *   .catch((errors) => {
 *     console.log('Oops!', errors)
 *   })
 *
 * // Output:
 * // Oops! [{
 * //   param: 'age',
 * //   value: 17,
 * //   validator: 'min',
 * //   min: 18,
 * //   message: 'Too young',
 * // }]
 */
var validate = function validate() {
  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var params = arguments[1];
  var paramPathPrefix = arguments[2];

  var schema = (0, _schema2.default)(params);
  var parsed = schema.parse(values);
  var promises = [];
  var errors = [];

  var transformValue = function transformValue(value, options, paramName, paramPath) {
    Object.keys(options).forEach(function (optionName) {
      var option = (0, _utils.parseValidatorOption)(options[optionName], optionName === "enum");
      var validator = schema.validators[optionName];

      if (typeof validator === "function") {
        var result = validator(value, option, paramPath, options, parsed, schema);
        var valid = result.valid,
            message = result.message,
            isSchema = result.isSchema;

        var args = [paramPath, value, optionName, option.optionValue, message];
        var errorObject = createErrorObject.apply(undefined, args);

        if (!valid) {
          errors.push(errorObject);
        } else if (typeof valid.catch === "function") {
          var promise = valid.catch(function (schemaErrors) {
            if (isSchema) {
              return errors.push.apply(errors, _toConsumableArray((0, _utils.toArray)(schemaErrors)));
            }
            return Promise.reject(errorObject);
          });
          promises.push(promise);
        }
      } else if (validator) {
        throw new Error("[schm] " + paramName + " validator must be a function");
      }
    });
  };

  (0, _mapValues2.default)(parsed, schema.params, transformValue, (0, _utils.toArray)(paramPathPrefix));

  return Promise.all(promises).then(function () {
    if (errors.length) {
      return Promise.reject(errors);
    }
    return parsed;
  }, function (e) {
    var allErrors = [].concat(errors, (0, _utils.toArray)(e));
    return Promise.reject(allErrors);
  });
};

exports.default = validate;