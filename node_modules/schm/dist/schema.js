"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.group = exports.defaultSchema = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _merge2 = require("lodash/merge");

var _merge3 = _interopRequireDefault(_merge2);

var _utils = require("./utils");

var _parsers = require("./parsers");

var _parsers2 = _interopRequireDefault(_parsers);

var _validators = require("./validators");

var _validators2 = _interopRequireDefault(_validators);

var _parse2 = require("./parse");

var _parse3 = _interopRequireDefault(_parse2);

var _validate2 = require("./validate");

var _validate3 = _interopRequireDefault(_validate2);

var _parseParams = require("./parseParams");

var _parseParams2 = _interopRequireDefault(_parseParams);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var defaultSchema = exports.defaultSchema = function defaultSchema() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    parsers: _parsers2.default,
    validators: _validators2.default,
    parse: function parse(values) {
      return (0, _parse3.default)(values, this);
    },
    validate: function validate(values, paramPathPrefix) {
      return (0, _validate3.default)(values, this, paramPathPrefix);
    },
    merge: function merge() {
      for (var _len = arguments.length, schemas = Array(_len), _key = 0; _key < _len; _key++) {
        schemas[_key] = arguments[_key];
      }

      var merged = _merge3.default.apply(undefined, [{}, this].concat(_toConsumableArray(schemas)));
      return _extends({}, merged, {
        params: (0, _parseParams2.default)(merged.params)
      });
    },

    params: (0, _parseParams2.default)(params)
  };
};

/**
 * A simple group of parameters. It's used internally when you pass literal
 * objects to [`schema`](#schema).
 * @example
 * const schema = require('schm')
 * const { group } = schema
 *
 * const userSchema = schema(
 *   group({
 *     id: String,
 *     name: String,
 *   }),
 *   group({
 *     age: Number,
 *   })
 * )
 */
var group = exports.group = function group() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (previous) {
    return previous.merge(defaultSchema(params));
  };
};

/**
 * Creates a schema by composing groups of parameters.
 * @example
 * const schema = require('schm')
 *
 * const userSchema = schema({
 *   id: String,
 *   name: String,
 * }, {
 *   age: Number
 * })
 *
 * // nested schema
 * const teamSchema = schema({
 *   users: [userSchema],
 * })
 */
var schema = function schema() {
  for (var _len2 = arguments.length, groups = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    groups[_key2] = arguments[_key2];
  }

  return groups.reduce(function (finalSchema, currentGroup) {
    if (typeof currentGroup === "function") {
      return currentGroup(finalSchema);
    } else if ((0, _utils.isSchema)(currentGroup)) {
      return finalSchema.merge(currentGroup);
    }
    return group(currentGroup)(finalSchema);
  }, defaultSchema());
};

exports.default = schema;